{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/context-query.js","webpack:///./src/context-style.js","webpack:///./src/context.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA,KAAK,4FAA4F;AACjG,KAAK,0FAA0F;AAC/F,KAAK,8GAA8G;AACnH,KAAK,6CAA6C;AAClD,KAAK,oFAAoF;AACzF,KAAK;AACL;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA,8B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uE;AACA,0DAA0D;AAC1D;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qI;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uF;AACA;AACA;AACA,6BAA6B;;AAE7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,6E;AACA;AACA,6BAA6B,E;AAC7B,yBAAyB;AACzB;AACA;AACA,a;AACA;;AAEA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;;AAEA,4B;AACA;AACA;AACA;AACA;AACA,S;AACA,K;;AAEA;AACA;AACA;;;AAGA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B;AACA;AACA,qBAAqB;AACrB;AACA;AACA,sC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO,4CAA4C;AACtE,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,yB;AACA,8C;AACA;AACA,iBAAiB;AACjB;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,wF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8CAA8C,sB;AAC9C,iC;AACA;AACA;AACA,sE;AACA;AACA,qCAAqC;AACrC,sE;AACA,qE;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,8CAA8C;AAC9C,iC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;AACA;;AAEA;AACA,yBAAyB,wC;AACzB,0C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;AACA;;AAEA,6BAA6B;AAC7B;AACA,uC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,uC;AACA;AACA,6B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,qB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,kD;AACA,kG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;AACA,qCAAqC;AACrC;AACA;AACA,yC;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,qC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA,6E;AACA;AACA;AACA,yC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qB;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iC;AACA;AACA;AACA,aAAa;AACb;AACA,8DAA8D,UAAU,4BAA4B;AACpG,a;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qB;AACA;AACA,C;;;;;;;;;;;;AC7hBA;AAAA;AAAA;AACA;AACA;AACe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA,mC;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gD;AACA,S;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,S;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;AACA;AACA,qB;AACA,iBAAiB;AACjB,iE;AACA;AACA,qB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAmE,yBAAyB,E;AAC5F,yBAAyB;AACzB,kFAAkF,WAAW,yBAAyB,E;AACtH;AACA,qBAAqB;AACrB,oGAAoG,WAAW,yBAAyB,E;AACxI;AACA,iBAAiB;AACjB;AACA,yDAAyD,yBAAyB;AAClF,qBAAqB;AACrB,uEAAuE,WAAW,yBAAyB;AAC3G;AACA,iB;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO,4CAA4C;AAClE,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;;AAEA,wC;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA;AACA;AACA,gEAAgE;AAChE,yDAAyD,yBAAyB;AAClF,4EAA4E;AAC5E;AACA,iD;AACA,wDAAwD;AACxD,qDAAqD,Q;AACrD;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,qDAAqD,E;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kCAAkC;AAChE;AACA,sG;AACA,qB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,S;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;ACtPD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACA","file":"context.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/context.js\");\n","/**\r\n * \r\n */\r\n // new features structure\r\nwindow.contextFeatures = [\r\n    { name: 'light-intensity', value: null, supported: 'ondevicelight' in window ? true : false },\r\n    { name: 'motion-speed', value: null, supported: 'ondevicemotion' in window ? true : false },\r\n    { name: 'touch', value: null, supported: 'ontouchstart' in window || navigator.maxTouchPoints ? true : false  },\r\n    { name: 'time', value: null, supported: true },\r\n    { name: 'battery', value: null, supported: 'getBattery' in navigator ? true : false },\r\n    { name: 'charging-battery', value: null, supported: 'getBattery' in navigator ? true : false }\r\n];\r\n\r\nexport default class ContextQuery {\r\n    constructor(query) {\r\n        // 'Private'\r\n        this._onchange = null;\r\n        this._listeners = {};\r\n        this._queries = this._breakQueriesDown(query);\r\n        this._intervalID = {};       \r\n        // 'Public'\r\n        this.context = query;\r\n        this.matches = this._determineMatch();\r\n        // attach event listeners\r\n        this._registerListeners();\r\n    }\r\n\r\n    _registerListeners() {\r\n        for( let feature of window.contextFeatures ) {\r\n            if ( feature.supported && this.context.includes(feature.name)) {\r\n                switch( feature.name ) {\r\n                    case 'light-intensity':\r\n                        window.addEventListener('devicelight', (e) => {      \r\n                            let normalised = e.value / 10; // normalise range from 0 to 100, max value on nexus 4 is 1000\r\n                            this._performContextCheck('light-intensity',Math.round(normalised));\r\n                        });\r\n                        break;\r\n                    case 'touch':\r\n                        this._performContextCheck('touch', ('ontouchstart' in window || navigator.maxTouchPoints)?true:false);\r\n                        break;\r\n                    case 'time':\r\n                        this._performContextCheck('time',(new Date().getHours() * 60) +  new Date().getMinutes());\r\n                        this._intervalID = setInterval(() => {\r\n                            this._performContextCheck('time',(new Date().getHours() * 60) +  new Date().getMinutes());\r\n                        },1000);\r\n                        break;\r\n                    case 'motion-speed':\r\n                        let acceleration = 0;\r\n                        window.addEventListener('devicemotion', function(e) {\r\n                            let accel = Math.round(Math.sqrt(e.acceleration.y*e.acceleration.y + e.acceleration.x*e.acceleration.x));   \r\n                            if (accel > acceleration || accel == 0) {\r\n                                acceleration = accel;\r\n                                this._performContextCheck('motion-speed', accel);\r\n                            }\r\n                        });\r\n                        break;\r\n                    case 'battery':\r\n                        navigator.getBattery().then((battery) => {\r\n                            this._performContextCheck('battery', battery.level * 100 );     \r\n                            battery.addEventListener('levelchange', () => {\r\n                                this._performContextCheck('battery', battery.level * 100 );\r\n                            });\r\n\r\n                        });\r\n                        break;\r\n                    case 'charging-battery':\r\n                        navigator.getBattery().then((battery) => {\r\n                            // Perform check on resolved promise then add change listener\r\n                            this._performContextCheck('charging-battery',battery.charging);\r\n                            battery.addEventListener('chargingchange',() => {         \r\n                                this._performContextCheck('charging-battery',battery.charging);\r\n                            });   \r\n                        });\r\n                        break;\r\n                }\r\n            }   \r\n        }\r\n        \r\n    }\r\n\r\n    /**   \r\n     * @param {string} fname the name of the feature\r\n     * @param {number} val the new numeric value\r\n     */\r\n    _performContextCheck(fname,val) {\r\n        // update the values passed by the listeners of this._registerListeners() in the window.contextFeatures object\r\n        for(let i of window.contextFeatures) {\r\n            if(i.name == fname) {\r\n                i.value = val;\r\n            }\r\n        }\r\n        this._determineMatch();\r\n    }\r\n\r\n    /**   \r\n     * @param {string} type \r\n     * @param {function} callback \r\n     */\r\n\r\n    addEventListener(type, callback) {\r\n        if (!(type in this._listeners)) {\r\n            this._listeners[type] = [];\r\n        }\r\n        this._listeners[type].push(callback);\r\n    };\r\n\r\n    /** \r\n     * @param {function} callback \r\n     */\r\n\r\n    addListener(callback) {\r\n        this.addEventListener(\"change\", callback);\r\n    }\r\n\r\n    /**   \r\n     * @param {string} type \r\n     * @param {function} callback \r\n     */\r\n\r\n    removeEventListener(type, callback) {\r\n        if (!(type in this._listeners)) {\r\n            return;\r\n        }\r\n        let stack = this._listeners[type];\r\n\r\n        for (let i in stack) {\r\n            console.log(stack[i]);  \r\n            if (stack[i].toString() === callback.toString()){\r\n                stack.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    };\r\n\r\n    /** \r\n     * @param {function} callback \r\n     */\r\n\r\n    removeListener(callback) {\r\n        this.removeEventListener(\"change\", callback)\r\n    }\r\n\r\n    /** \r\n     * @param {CustomEvent} event \r\n     */\r\n\r\n    dispatchEvent(event) {\r\n        if (!(event.type in this._listeners)) {\r\n            return true;\r\n        }\r\n        let stack = this._listeners[event.type];\r\n\r\n        //event.target = this;\r\n        for (let elm of stack) {\r\n            elm.call(this, event);\r\n        }\r\n        return !event.defaultPrevented;\r\n    };\r\n\r\n    /** \r\n     * @param {function} callback \r\n     */\r\n\r\n    set onchange(callback) {    \r\n        if(typeof callback == \"function\") {\r\n            this.removeEventListener(\"change\", this._onchange);\r\n            this._onchange = callback;\r\n            this.addEventListener(\"change\", callback);\r\n        } \r\n    } \r\n\r\n    get onchange() {\r\n        return this._onchange;\r\n    }\r\n\r\n\r\n    /**   \r\n     * @param {string} context \r\n     */\r\n    _breakQueriesDown(context) {\r\n        /**\r\n         * @param {array} arr the resulting array after having splitted the query using <= or >=\r\n         * @param {string} symbol the character to look up for in the passed array, either < or >\r\n         */\r\n        function mixedSigns(arr,symbol) {\r\n            let o = {left:false,right:false};\r\n            if (arr.length == 2) {\r\n                let left = false, tmpArr, tmpStr;\r\n                for (let idx in arr) {            \r\n                    // check if symbol is present\r\n                    if(arr[idx].includes(symbol)) {\r\n                        tmpStr = arr[idx];\r\n                        arr.splice(idx,1);\r\n                        if(idx==0) {\r\n                            left = true;\r\n                        } \r\n                    }\r\n                }\r\n                // if tmpStr has been assigned value\r\n                if(tmpStr != undefined) {\r\n                    tmpArr = tmpStr.split(symbol);\r\n                    if (left) {\r\n                        arr.unshift(tmpArr[1]);\r\n                        arr.unshift(tmpArr[0]);\r\n                        if( symbol === '<') {\r\n                            o.left = true;\r\n                        } else {\r\n                            o.right = true;\r\n                        }\r\n                        \r\n                    } else {\r\n                        arr.push(tmpArr[0]);\r\n                        arr.push(tmpArr[1]);\r\n                        if( symbol === '<') {\r\n                            o.right = true;\r\n                        } else {\r\n                            o.left = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return o;\r\n        }\r\n\r\n        /**\r\n         * @param {string} brackets the type of brackets as pair [],{},()\r\n         * @param {string} str the string where the brackets are to be found \r\n         */\r\n\r\n        function findClosingBracket(start, str){\r\n            let c = str.indexOf('(', start);\r\n            let i = 1;\r\n            while (i > 0) {\r\n                let b = str[++c];\r\n                if (b == '(') {\r\n                    i++;\r\n                }\r\n                else if (b == ')') {\r\n                    i--;\r\n                }\r\n            }\r\n            return c;\r\n        }\r\n\r\n        let tree = { queries: [] };\r\n\r\n        /**\r\n         * @param {object} obj an object representing all relations between the queries of which the context is composed \r\n         * such an object has the following structure:\r\n         * {\r\n         *  operator: 'and' | 'or' // optional: the operator combining two or more queries\r\n         *  negate: true // optional: whether the expression has been prefixed with 'not'\r\n         *  queries: [ // array of objects\r\n         *      { // an object representing a query\r\n         *          context: '120 < time < 600', // the query\r\n         *          feature: 'time', // the name of the feature\r\n         *          lt_gt: { // optional when using < or >\r\n         *              left: true | false,\r\n         *              right: true | false\r\n         *          },\r\n         *          max: 600, // optional: the max value specified in the query\r\n         *          min: 120, // optional: the min value specified in the query\r\n         *          abs: true | 'string' // optional: whether the query has an absolute value \r\n         *      },\r\n         *      { // an object with the same structure as its parent\r\n         *          operator: 'and',\r\n         *          queries: [\r\n         *              ...\r\n         *          ]\r\n         *      }\r\n         *  ]\r\n         * }\r\n         * @param {string} context the composed context \r\n         */\r\n\r\n        function createQueryTreeRecursively(obj,context) {\r\n            let q = '', idx = context.indexOf('(');\r\n\r\n            // check if the expression has prefix 'not', if so set idx to 0 \r\n            if(context.substring(idx - 3,idx) === 'not') {\r\n                idx = idx - 3;\r\n            }\r\n            // if idx != 0 we're dealing with an operator\r\n            if(idx != 0) {\r\n                q = context.substring(0, idx);    \r\n            } else  {\r\n                q = context.substring(idx, findClosingBracket(idx,context) + 1);\r\n            }\r\n            // replace the substring \r\n            context = context.replace(q,'');\r\n            q = q.trim();\r\n            \r\n            if(q !== ''){ \r\n                if( q == 'or' || q == 'and') { \r\n                    obj.operator = q;\r\n                } else {\r\n                    if(!q.includes('and') && !q.includes('or') ) {\r\n                        let ra, prcnt = '%', objct = {}, objName, incdec, lt = '<', gt = '>', lteq = '<=', gteq = '>=';\r\n                        if(q.substring(q.indexOf('(') - 3,q.indexOf('(')) === 'not') {\r\n                            objct.negate = true;\r\n                        }\r\n                        objct.context = q.substring(q.indexOf('(') + 1, q.indexOf(')'));\r\n                        if( objct.context.includes(lt) || objct.context.includes(gt) ) {               \r\n                            if (objct.context.includes(lt) && objct.context.includes(gt)) {\r\n                                console.error('you have mixed the greater than and less than symbol in an expression!');\r\n                                return;\r\n                            }\r\n                            if (objct.context.includes(lt)) {\r\n                                if (objct.context.includes(lteq)) {\r\n                                    ra = objct.context.split(lteq);\r\n                                    incdec = mixedSigns(ra,lt);\r\n                                } else {\r\n                                    ra = objct.context.split(lt);\r\n                                    incdec = {left:true,right:true};   \t\r\n                                }  \r\n                                if(ra.length == 2) {\r\n                                    if(ra[0].includes(prcnt) || !isNaN(ra[0])) {\r\n                                        objct.min = parseFloat(ra[0]); \r\n                                        objct.feature = ra[1].trim();\r\n                                    } else {\r\n                                        objct.max = parseFloat(ra[1]); \r\n                                        objct.feature = ra[0].trim();                                \r\n                                    }\r\n                                } else {\r\n                                    objct.feature = ra[1].trim();\r\n                                    objct.min = parseFloat(ra[0]);\r\n                                    objct.max = parseFloat(ra[2]);\r\n                                }\r\n                                \r\n                                if( incdec.left || incdec.right ) {\r\n                                    objct.lt_gt = incdec;\r\n                                }\r\n                                q = {};                 \r\n                                q = objct;\r\n                            }\r\n                            if (objct.context.includes(gt)) {\r\n                                if (objct.context.includes(gteq)) {\r\n                                    ra = objct.context.split(gteq);\r\n                                    incdec = mixedSigns(ra,gt);\r\n                                } else {\r\n                                    ra = objct.context.split(gt);\r\n                                    incdec = {left:true,right:true};\r\n                                } \r\n                                if(ra.length == 2) {\r\n                                    if(ra[0].includes(prcnt) || !isNaN(ra[0])) {\r\n                                        objct.max = parseFloat(ra[0]);\r\n                                        objct.feature = ra[1].trim();\r\n                                    } else {\r\n                                        objct.min = parseFloat(ra[1]);\r\n                                        objct.feature = ra[0].trim();\r\n                                    }\r\n                                    \r\n                                } else {\r\n                                    objct.feature = ra[1].trim();\r\n                                    objct.max = parseFloat(ra[0]);\r\n                                    objct.min = parseFloat(ra[2]);\r\n                                }\r\n                                if( incdec.left || incdec.right ) {\r\n                                    objct.lt_gt = incdec;\r\n                                }\r\n                                q = {};                 \r\n                                q = objct;\r\n                                \r\n                            }\r\n                        } else if( objct.context.includes(':')) {                \r\n                            let a, objVal;          \r\n                            a = objct.context.split(/\\s*:\\s*/);\r\n                            objName = a[0].trim();\r\n                            objct.feature = objName;\r\n                            objVal = parseFloat(a[1]);\r\n                            \r\n                            if( objName.includes('min-') || objName.includes('max-')) {\r\n                                objName = objName.replace('min-','');\r\n                                objName = objName.replace('max-','');\r\n                                objct.feature = objName;\r\n                                if(a[0].includes('min-')) {\r\n                                    objct.min = objVal;\r\n                                }\r\n                                if(a[0].includes('max-')) {\r\n                                    objct.max = objVal;\r\n                                }\r\n                                q = {};                 \r\n                                q = objct;\r\n                                 \r\n                            } else {\r\n                                objct.abs = objVal;\r\n                                q = {};                 \r\n                                q = objct;\r\n                            }\r\n                        } else {\r\n                            if(objct.context) {\r\n                                objct.feature = objct.context;\r\n                                objct.abs = true;\r\n                                q = {};             \r\n                                q = objct;\r\n                            }  \r\n                        }\r\n                    }\r\n                    obj.queries.push(q);\r\n                }\r\n                // carry on recursively with the rest of the string\r\n                createQueryTreeRecursively(obj,context);\r\n            } else {\r\n                for(let i in obj.queries){\r\n                    if(typeof obj.queries[i] === 'string') {\r\n                        context = obj.queries[i];\r\n                        obj.queries[i] = { queries: [] };\r\n                        if(context.substring(context.indexOf('(') - 3,context.indexOf('(')) === 'not') {\r\n                            context = context.replace('not','');\r\n                            obj.queries[i].negate = true;\r\n                        }\r\n                        context = context.substring(context.indexOf('(') + 1, findClosingBracket(context.indexOf('('),context));\r\n                        \r\n                        createQueryTreeRecursively(obj.queries[i],context);\r\n                    }       \r\n                }\r\n            }\r\n        }\r\n\r\n        createQueryTreeRecursively(tree,context.trim());\r\n\r\n        return tree;\r\n        \r\n    }\r\n\r\n    _determineMatch() {\r\n        /** \r\n        * @param {object} obj the object representing the combined queries in a tree-like structure  \r\n        */\r\n        function evaluateQueriesRecursively(obj) {\r\n            let tmp, operator;\r\n\r\n            // check if the combined query has been prefixed with 'not', if so invert the operators\r\n            if(obj.hasOwnProperty('negate')) {\r\n                if(obj.operator === 'and') {\r\n                    operator = 'or';\r\n                } else if(obj.operator === 'or') {\r\n                    operator = 'and';\r\n                }\r\n            } else {\r\n                operator = obj.operator;\r\n            }\r\n\r\n            for(let q of obj.queries) {\r\n                if(!q.hasOwnProperty('queries')) {      \r\n                    let b1 = true, min = Number.NEGATIVE_INFINITY, max = Number.POSITIVE_INFINITY; \r\n                    for(let feature of window.contextFeatures ){\r\n                        if(feature.name === q.feature) {\r\n                            // Compare to values stored in Features object\r\n                            if(feature.supported) {\r\n                                // has an unique value either numeric or boolean\r\n                                if(q.hasOwnProperty('abs')) {\r\n                                    if(Number.isInteger(q.abs)) {\r\n                                        if(feature.value != q.abs) {\r\n                                            b1 = false;\r\n                                        } \r\n                                    } else {\r\n                                        if(!feature.value) {\r\n                                            b1 = false;\r\n                                        } \r\n                                    }\r\n                                } else {\r\n                                    // Value is in range\r\n                                    if(q.hasOwnProperty('min')) {\r\n                                        min = q.min;\r\n                                    }         \r\n                                    if(q.hasOwnProperty('max')) {\r\n                                        max = q.max;\r\n                                    }\r\n                                    if(q.hasOwnProperty('lt_gt')) {\r\n                                        if(q.lt_gt.left) {\r\n                                            ++min;\r\n                                        } \r\n                                        if(q.lt_gt.right) {\r\n                                            --max;\r\n                                        }\r\n                                    }\r\n                                    if(min != -Infinity || max != Infinity) {                                  \r\n                                        if ( feature.value < min || max < feature.value) {\r\n                                            b1 = false;\r\n                                        }        \r\n                                    }\r\n                                }\r\n                                if(q.hasOwnProperty('negate')) {\r\n                                    b1 = !b1;\r\n                                }\r\n                            } else {\r\n                                b1 = false;\r\n                            }\r\n                        }  \r\n                    }\r\n                    if(obj.hasOwnProperty('negate')) {\r\n                        b1 = !b1;\r\n                    }\r\n                    \r\n                    if (obj.queries.indexOf(q) === 0) {\r\n                        tmp = b1;\r\n                    } else {\r\n                        if(operator === 'and') {\r\n                            tmp = tmp && b1;\r\n                        }\r\n                        if(operator === 'or') {\r\n                            tmp = tmp || b1;\r\n                        }\r\n                    }\r\n                  \r\n                } else {\r\n                    if (obj.queries.indexOf(q) !== 0){\r\n                        if(operator === 'and') {\r\n                            tmp = tmp && evaluateQueriesRecursively(q);\r\n                        }\r\n                        if(operator === 'or') {\r\n                            tmp = tmp || evaluateQueriesRecursively(q);\r\n                        }\r\n                    } else {\r\n                        tmp = evaluateQueriesRecursively(q);\r\n                    }   \r\n                }\r\n            }\r\n            return tmp;\r\n        }\r\n\r\n        let b = evaluateQueriesRecursively(this._queries);\r\n\r\n        if( b != this.matches ) {            \r\n            if(this.matches == undefined) {\r\n                return b;\r\n            } else {\r\n                this.matches = b;\r\n                this.dispatchEvent(new CustomEvent(\"change\", { detail: { matches: b, target: this }}));\r\n            }           \r\n        }\r\n        \r\n    }\r\n}\r\n\r\n// matchContext function to instantiate ContextQueryList Object with -- let varname = window.matchContext(\"(touch)\") -- \r\nwindow.matchContext = function(expression) {\r\n    let o = new ContextQuery(expression);\r\n    //console.log(o);            \r\n    return o;\r\n}","/**\r\n * \r\n */\r\nexport default class ContextStyle extends HTMLElement {\r\n\r\n    constructor() {\r\n        super();\r\n        this._arrayOfQueries = [];\r\n        this._host = document.querySelector(\"html\");\r\n        this._head = document.querySelector('head');\r\n        this._contextQueryObjectList = [];\r\n    }\r\n\r\n    connectedCallback() {\r\n        this.style.display = 'none';\r\n        if(this.parentNode.host != undefined) {\r\n            if(!this.parentNode.host.shadowRoot.querySelector('slot')) {\r\n                this._host = this.parentNode.host;\r\n                this._head = this._host.shadowRoot;\r\n            }\r\n        }\r\n        this.getHrefAttr();\r\n    }\r\n\r\n    disconnectedCallback() {\r\n        for(let i in this._contextQueryObjectList) {\r\n            if(this._contextQueryObjectList[i]._intervalID != undefined) {\r\n                clearInterval(this._contextQueryObjectList[i]._intervalID);\r\n            }\r\n            this._contextQueryObjectList[i] = null;\r\n            delete this._contextQueryObjectList[i];\r\n        }\r\n        for(let j of this._arrayOfQueries) {\r\n            this._host.classList.remove(j.class);\r\n        }\r\n        this._contextQueryObjectList.length = 0;\r\n        //console.log(this._contextQueryObjectList);\r\n    }\r\n\r\n    /**\r\n     * @param {string} attr - the query from the \"context\" attribute   \r\n     */\r\n    getContent(attr) {\r\n        let inner = this.innerHTML;  \r\n        if(inner.trim() != ''){\r\n            inner = inner.replace(/&gt;/g, '>').replace(/&lt;/g, '<');\r\n            this.instantiateContextQueryObjects( inner.trim(), attr );\r\n        } else {\r\n            console.error('Context-Styles have not been declared, please use the href attribute or write them directly in the context-style tag.');\r\n        }\r\n                \r\n    }\r\n\r\n    getHrefAttr() {\r\n        let attr = false;\r\n        if(this.hasAttribute('context') && this.getAttribute('context') != \"\") {\r\n            attr = this.getAttribute('context'); \r\n        } \r\n        if(this.hasAttribute('href') && this.getAttribute('href') != \"\") {\r\n            this.getURL(this.getAttribute('href')).then((response) => {\r\n                this.instantiateContextQueryObjects(response, attr);\r\n                //this.content(attr);\r\n            }, (error) => {\r\n                console.error(\"Failed!\", error);\r\n            });\r\n        } else {\r\n            //console.log('href empty or non existent');\r\n            this.getContent(attr);\r\n        }   \r\n    }\r\n\r\n    /**   \r\n     * @param {string} url - the link to an external context query sheet\r\n     */\r\n\r\n    getURL(url) {\r\n        return new Promise(function(resolve, reject) {\r\n            var req = new XMLHttpRequest();\r\n            req.open('GET', url);\r\n            req.onload = function() {\r\n                if (req.status == 200) {\r\n                    resolve(req.response);\r\n                }\r\n                else {\r\n                    reject(Error(req.statusText));\r\n                }\r\n            };\r\n            req.onerror = function() {\r\n                reject(Error(\"Network Error\"));\r\n            };\r\n            req.send();\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @param {string} str the styles found inside the <context-style> custom element\r\n     * @param {string} attr the query of the \"context\" attribute \r\n     */\r\n\r\n    instantiateContextQueryObjects(str,attr) {\r\n        this.factoriseContextQueries(str,attr);\r\n        for(let contextQuery of this._arrayOfQueries) {\r\n            // Generate unique class;\r\n            // unary operator in +new Date equivalent to Number(new Date)\r\n            const cssClass = 'css-ctx-queries-' + (+new Date).toString(36) + this._arrayOfQueries.indexOf(contextQuery);\r\n            contextQuery.class = cssClass;\r\n            // Instantiate Object with new constructor\r\n            let cqo = window.matchContext(contextQuery.expression), css = \"\";\r\n            // Define a callback on change\r\n            cqo.onchange = (e) => {\r\n                if(e != undefined) {\r\n                    console.log(e);\r\n                }\r\n                if( cqo.matches ) {\r\n                    if(!this._host.classList.contains(cssClass)){                   \r\n                        this._host.classList.add(cssClass);\r\n                    }       \r\n                } else  {\r\n                    if(this._host.classList.contains(cssClass)) {         \r\n                        this._host.classList.remove(cssClass);\r\n                    }             \r\n                }\r\n            }\r\n            // trigger the callback for the first time\r\n            cqo.onchange();\r\n\r\n            this._contextQueryObjectList.push(cqo);\r\n            \r\n            for(let style of contextQuery.styles) {\r\n                let key = style.selector;\r\n                if(this._host.shadowRoot != undefined) {\r\n                    if(!this._host.shadowRoot.querySelector('slot')) {\r\n                        if(key == ':host') {\r\n                            css += ':host(.' + cssClass + ') ' + '{' + style.properties + '}'; \r\n                        } else {\r\n                            css += ':host(.' + cssClass + ') ' + key.replace('&gt;','>') + '{' + style.properties + '}';                            \r\n                        }\r\n                    } else {\r\n                        css += '.' + cssClass + ' ' + this._host.localName + ' ' + key.replace('&gt;','>') + '{' + style.properties + '}'; \r\n                    }\r\n                } else {\r\n                    if(key === 'html') {\r\n                        css += key +  '.' + cssClass + '{' + style.properties + '}';\r\n                    } else {\r\n                        css += '.' + cssClass + ' ' + key.replace('&gt;','>') + '{' + style.properties + '}';\r\n                    }\r\n                }  \r\n            }\r\n            \r\n            if(this._head.querySelector('#cssCtxQueriesStyleTag')) {\r\n                this._head.querySelector('#cssCtxQueriesStyleTag').appendChild(document.createTextNode(css));\r\n            } else {\r\n                let style = document.createElement('style');\r\n                style.id = 'cssCtxQueriesStyleTag';\r\n                style.appendChild(document.createTextNode(css));\r\n                this._head.appendChild(style);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {string} brackets the type of brackets as pair [],{},()\r\n     * @param {string} str the string where the brackets are to be found \r\n     */\r\n\r\n    findClosingBracket(brackets, str){\r\n        let c = str.indexOf(brackets[0], str.indexOf('@context'));\r\n        let i = 1;\r\n        while (i > 0) {\r\n            let b = str[++c];\r\n            if (b == brackets[0]) {\r\n                i++;\r\n            }\r\n            else if (b == brackets[1]) {\r\n                i--;\r\n            }\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @param {string} str - the content of the <context-style> custom element\r\n     * @param {string} attr - the content of the context attribute, false if the context attribute is empty\r\n     */\r\n\r\n    factoriseContextQueries(str, attr) { \r\n        if(str.includes('@context')){\r\n            let sbstrng = str.substring(str.indexOf(\"@context\"), this.findClosingBracket('{}',str) + 1);\r\n            let str2 = str.replace(sbstrng,'');\r\n            str2 = str2.trim();\r\n            this._arrayOfQueries.push(sbstrng);\r\n            this.factoriseContextQueries(str2, attr);\r\n        } else {\r\n            // push the query from the context attribute into _arrayOfQueries\r\n            if(attr != false) {\r\n                this._arrayOfQueries.push('@context '+ attr +' {'+ str + '}');\r\n            }\r\n            let newArrayOfQueries = [];\r\n            for (let elm of this._arrayOfQueries) {\r\n                let expression = elm.substring(8, elm.indexOf('{'));\r\n                let styles = elm.substring(elm.indexOf('{') + 1,elm.lastIndexOf('}'));\r\n                let arrayOfSelectors = [], singleStyles = styles.split(/\\s*}\\s*/);\r\n                for (let z of singleStyles){\r\n                    let classes, attrs, classArr; \r\n                    classes = z.substring(0,z.indexOf(\"{\"));\r\n                    attrs =  z.substring(z.indexOf(\"{\") + 1);                            \r\n                    classArr = classes.split(/\\s*,\\s*/);\r\n                    for(let sc of classArr) {\r\n                        let obj = { selector: sc.trim(), properties: attrs.trim() };\r\n                        if(obj.selector != \"\" || obj.properties !== \"\") {\r\n                            arrayOfSelectors.push(obj);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                newArrayOfQueries.push({expression:expression.trim(),styles:arrayOfSelectors});  \r\n            }\r\n            \r\n            // factorise all objects in _arrayOfQueries only if there's a global query and more than one query in total \r\n            if(attr != false) {\r\n                let globalQuery = newArrayOfQueries[newArrayOfQueries.length - 1].expression;\r\n                if(globalQuery.includes('or') || globalQuery.includes(',')) {\r\n                    globalQuery = '(' + globalQuery + ')';\r\n                }\r\n                for(let i = 0; i < newArrayOfQueries.length - 1; i++) {\r\n                    if(newArrayOfQueries[i].expression.includes('or') || newArrayOfQueries[i].expression.includes(',')) {\r\n                        newArrayOfQueries[i].expression = '(' + newArrayOfQueries[i].expression + ')'; \r\n                    } \r\n                    newArrayOfQueries[i].expression += ' and ' + globalQuery;\r\n                }\r\n                \r\n            }\r\n            this._arrayOfQueries = [];\r\n            // reorganise arrayOfQueries\r\n            for (let i of newArrayOfQueries) {\r\n                if(i.styles.length > 0) {\r\n                    this._arrayOfQueries.push(i);\r\n                }\r\n            }\r\n        }      \r\n    }\r\n    \r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n    window.customElements.define('context-style', ContextStyle);\r\n});\r\n","import ContextQuery from './context-query';\r\nimport ContextStyle from './context-style';\r\n\r\nexport {ContextQuery, ContextStyle};"],"sourceRoot":""}